# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#        GC-MS Data Analysis Workflow in R - FINAL DEFINITIVE VERSION
#
#   This script has been rigorously debugged through a collaborative process.
#   It is designed to work with modern Bioconductor packages (xcms 4.x, Spectra)
#   and accommodates issues with older .CDF file formats and unstable function
#   names in development versions.
#
#   - The CAMERA/Feature Grouping step has been REMOVED for robustness.
#   - The Consensus Spectrum generation is now a robust, two-step process.
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# ============================================================================
# 1. SETUP: INSTALL AND LOAD PACKAGES
# ============================================================================
setwd("~/projects/kintagen/server/")
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

bioc_packages <- c("xcms", "MSnbase", "faahKO", "BiocParallel")
cran_packages <- c("tidyverse", "pheatmap", "RColorBrewer")

# Install Bioconductor packages if not present
for (pkg in bioc_packages) {
  if (!requireNamespace(pkg, quietly = TRUE))
    BiocManager::install(pkg)
}

# Install CRAN packages if not present
for (pkg in cran_packages) {
  if (!require(pkg, character.only = TRUE))
    install.packages(pkg)
}

# Load all the libraries for the session
library(xcms)
library(MSnbase)
library(faahKO)
library(mzR) # Load the low-level reader
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(BiocParallel) # Explicitly load for SerialParam()
# --- 2. Get Command Line Arguments (No Change) ---
args <- commandArgs(trailingOnly = TRUE)
if (length(args) == 0) {
  message("No input URL provided. Usage: Rscript <script_name>.R <url_to_csv>", call. = FALSE)
}
inputFile <- args[1]

# ============================================================================
# 2. DATA PREPARATION
# ============================================================================

data_path <- system.file("cdf", package = "faahKO")
file_list <- list.files(data_path, pattern = "CDF", full.names = TRUE, recursive = TRUE)

pheno_data <- data.frame(
  sample_name = basename(file_list),
  sample_group = c(rep("KO", 6), rep("WT", 6)),
  polarity = 1, # 1 for positive mode (standard for GC-EI-MS)
  stringsAsFactors = FALSE
)

message("Sample Metadata (Phenodata):")
message(pheno_data)


# ============================================================================
# 3. XCMS PROCESSING
# ============================================================================

raw_data <- readMSData(files = file_list, 
                       pdata = Biobase::AnnotatedDataFrame(pheno_data), 
                       mode = "onDisk")

cwp <- CentWaveParam(
  ppm = 25,
  peakwidth = c(5, 20),
  snthresh = 10,
  prefilter = c(3, 1000)
)
xdata <- findChromPeaks(raw_data, param = cwp)

pdp <- PeakDensityParam(
  sampleGroups = xdata$sample_group,
  minFraction = 0.5,
  bw = 5
)
xdata <- groupChromPeaks(xdata, param = pdp)

pgp <- PeakGroupsParam(
  minFraction = 0.7, 
  span = 0.4
)
xdata <- adjustRtime(xdata, param = pgp)

xdata <- groupChromPeaks(xdata, param = pdp)

fcp <- FillChromPeaksParam(expandMz = 0, expandRt = 0, ppm = 5)
xdata <- fillChromPeaks(xdata, param = fcp)

# Get the final feature matrix and definitions. This is the final processing step.
feature_matrix <- featureValues(xdata, value = "into")
feature_definitions <- featureDefinitions(xdata)

cat("\nDimensions of the final feature matrix:", dim(feature_matrix), "\n")


# ============================================================================
# SECTION 4 HAS BEEN REMOVED
# All statistical analysis will be performed on the features generated by XCMS.
# ============================================================================


# ============================================================================
# 5. STATISTICAL ANALYSIS & VISUALIZATION
# ============================================================================

# --- Data Preparation for Statistics ---
stats_matrix <- feature_matrix
stats_matrix[is.na(stats_matrix)] <- 0
stats_matrix[stats_matrix == 0] <- 1
log_matrix <- log2(stats_matrix)

# --- 5.1 Principal Component Analysis (PCA) ---
pca_res <- prcomp(t(log_matrix), center = TRUE, scale. = TRUE)
pca_df <- data.frame(
  PC1 = pca_res$x[, 1],
  PC2 = pca_res$x[, 2],
  Group = xdata$sample_group
)
percent_var <- round(100 * pca_res$sdev^2 / sum(pca_res$sdev^2), 1)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Group)) +
  geom_point(size = 4, alpha = 0.8) +
  labs(
    title = "PCA of GC-MS Data",
    x = paste0("PC1 (", percent_var[1], "%)"),
    y = paste0("PC2 (", percent_var[2], "%)")
  ) +
  theme_bw() +
  scale_color_brewer(palette = "Set1")

# --- 5.2 Differential Abundance Analysis ---
stats_results <- apply(log_matrix, 1, function(row) {
  ko_values <- row[pheno_data$sample_group == "KO"]
  wt_values <- row[pheno_data$sample_group == "WT"]
  t_test <- t.test(ko_values, wt_values)
  log2FC <- mean(ko_values, na.rm = TRUE) - mean(wt_values, na.rm = TRUE)
  return(c(log2FC = log2FC, p_value = t_test$p.value))
})
stats_results <- as.data.frame(t(stats_results))
stats_results$feature <- rownames(feature_matrix)
stats_results$p_adj <- p.adjust(stats_results$p_value, method = "fdr")

# --- Get top significant features ---
top_features <- stats_results %>%
  filter(abs(log2FC) > 1 & p_adj < 0.05) %>%
  arrange(p_adj)


# ============================================================================
# 6. INSPECTING A SPECIFIC FEATURE OF INTEREST
# ============================================================================

if (nrow(top_features) > 0) {
  top_feature_id <- top_features$feature[1] 
  cat("\nInspecting the top feature:", top_feature_id, "\n")
  
  feat_info <- featureDefinitions(xdata)[top_feature_id, ]
  mz_range <- c(feat_info$mzmed - 0.005, feat_info$mzmed + 0.005)
  rt_range <- c(feat_info$rtmed - 3, feat_info$rtmed + 3)
  
  eic <- chromatogram(xdata, mz = mz_range, rt = rt_range)
  plot(eic, col = brewer.pal(n_distinct(eic$sample_group), "Set1")[as.factor(eic$sample_group)], peakBg = NA)
  title(main = paste("EIC for Feature", top_feature_id))
  plotFeatureGroups(xdata, feature = top_feature_id)
  title(main = paste("Representative Spectrum for", top_feature_id))
  # --- Plot a Representative Spectrum using the LOW-LEVEL mzR reader ---
  # This bypasses the broken xcms/Spectra backend for CDF files.
  
  cat("\nExtracting representative spectrum using low-level mzR...\n")
  
  # 1. Find the sample file with the highest intensity for this feature.
  top_feature_intensities <- feature_matrix[top_feature_id, ]
  best_sample_index <- which.max(top_feature_intensities)
  best_sample_file <- file_list[best_sample_index]
  cat("Found best signal for this feature in file:", basename(best_sample_file), "\n")
  
  # 2. Open this specific file with mzR.
  ms_file <- mzR::openMSfile(best_sample_file)
  
  # 3. Get the retention time of our feature from the xcms results.
  target_rt <- feat_info$rtmed
  
  # 4. Find the scan number closest to this retention time.
  scan_headers <- mzR::header(ms_file)
  closest_scan_index <- which.min(abs(scan_headers$retentionTime - target_rt))
  
  # 5. Extract the peak data (m/z and intensity) for that single scan.
  peak_data <- mzR::peaks(ms_file, closest_scan_index)
  
  # 6. Close the file.
  mzR::close(ms_file)
  
  # 7. Plot the spectrum as a stick plot.
  if (nrow(peak_data) > 0) {
    # Create a new plot window
    plot(peak_data, type = "h", col = "blue",
         xlab = "m/z", ylab = "Intensity",
         main = paste("Representative Spectrum for", top_feature_id,
                      "\n(from", basename(best_sample_file), ")"))
  } else {
    cat("Could not extract peak data for the best scan. The file might be corrupted.\n")
  }
  
} else {
  cat("\nNo significant features found with the current thresholds.\n")
}

# Export all statistical results.
output_dir <- "results/xcms"
if (!dir.exists(output_dir)) dir.create(output_dir)
write.csv(stats_results, file = file.path(output_dir, "differential_analysis_results.csv"))

cat("\nAnalysis complete! Check the '", output_dir, "' directory for results.\n")
